# Japanese translations for PACKAGE package
# Copyright (C) 2017 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# Automatically generated, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2017-12-03 14:26+0900\n"
"PO-Revision-Date: 2017-09-30 21:43+0900\n"
"Last-Translator: Automatically generated\n"
"Language-Team: matsuand個人翻訳\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Plain text
#: Cross-compilation.md:1
#, no-wrap
msgid "---\n"
msgstr ""

#. type: Plain text
#: Cross-compilation.md:4
msgid "short-description: Setting up cross-compilation ..."
msgstr ""
"short-description: クロスコンパイルの設定\n"
"..."

#. type: Plain text
#: Cross-compilation.md:6
msgid "# Cross compilation"
msgstr "# クロスコンパイル"

#. type: Plain text
#: Cross-compilation.md:14
msgid ""
"Meson has full support for cross compilation. Since cross compiling is more "
"complicated than native building, let's first go over some nomenclature. The "
"three most important definitions are traditionally called *build*, *host* "
"and *target*. This is confusing because those terms are used for quite many "
"different things. To simplify the issue, we are going to call these the "
"*build machine*, *host machine* and *target machine*. Their definitions are "
"the following"
msgstr ""

#. type: Bullet: '* '
#: Cross-compilation.md:18
msgid "*build machine* is the computer that is doing the actual compiling"
msgstr ""

#. type: Bullet: '* '
#: Cross-compilation.md:18
msgid "*host machine* is the machine on which the compiled binary will run"
msgstr ""

#. type: Bullet: '* '
#: Cross-compilation.md:18
msgid ""
"*target machine* is the machine on which the compiled binary's output will "
"run (this is only meaningful for programs such as compilers that, when run, "
"produce object code for a different CPU than what the program is being run "
"on)"
msgstr ""

#. type: Plain text
#: Cross-compilation.md:24
msgid ""
"The `tl/dr` summary is the following: if you are doing regular cross "
"compilation, you only care about *build_machine* and *host_machine*. Just "
"ignore *target_machine* altogether and you will be correct 99% of the time. "
"If your needs are more complex or you are interested in the actual details, "
"do read on."
msgstr ""

#. type: Plain text
#: Cross-compilation.md:28
msgid ""
"This might be easier to understand through examples. Let's start with the "
"regular, not cross-compiling case. In these cases all of these three "
"machines are the same. Simple so far."
msgstr ""

#. type: Plain text
#: Cross-compilation.md:35
msgid ""
"Let's next look at the most common cross-compilation setup. Let's suppose "
"you are on a 64 bit OSX machine and you are cross compiling a binary that "
"will run on a 32 bit ARM Linux board. In this case your *build machine* is "
"64 bit OSX and both your *host* and *target machines* are 32 bit ARM Linux. "
"This should be quite understandable as well."
msgstr ""

#. type: Plain text
#: Cross-compilation.md:40
msgid ""
"It gets a bit trickier when we think about how the cross compiler was "
"generated. It was built and it runs on a specific platform but the output it "
"generates is for a different platform. In this case *build* and *host "
"machines* are the same, but *target machine* is different."
msgstr ""

#. type: Plain text
#: Cross-compilation.md:52
msgid ""
"The most complicated case is when you cross-compile a cross compiler. As an "
"example you can, on a Linux machine, generate a cross compiler that runs on "
"Windows but produces binaries on MIPS Linux. In this case *build machine* is "
"x86 Linux, *host machine* is x86 Windows and *target machine* is MIPS Linux. "
"This setup is known as the [Canadian Cross](https://en.wikipedia.org/wiki/"
"Cross_compiler#Canadian_Cross). As a side note, be careful when reading "
"cross compilation articles on Wikipedia or the net in general. It is very "
"common for them to get build, host and target mixed up, even in consecutive "
"sentences, which can leave you puzzled until you figure it out."
msgstr ""

#. type: Plain text
#: Cross-compilation.md:57
msgid ""
"If you did not understand all of the details, don't worry. For most people "
"it takes a while to wrap their head around these concepts. Don't panic, it "
"might take a while to click, but you will get the hang of it eventually."
msgstr ""

#. type: Plain text
#: Cross-compilation.md:59
msgid "## Defining the environment"
msgstr ""

#. type: Plain text
#: Cross-compilation.md:65
msgid ""
"Meson requires you to write a cross build definition file. It defines "
"various properties of the cross build environment. The cross file consists "
"of different sections. The first one is the list of executables that we are "
"going to use. A sample snippet might look like this:"
msgstr ""

#. type: Plain text
#: Cross-compilation.md:75
msgid ""
"```ini [binaries] c = '/usr/bin/i586-mingw32msvc-gcc' cpp = '/usr/bin/i586-"
"mingw32msvc-g++' ar = '/usr/i586-mingw32msvc/bin/ar' strip = '/usr/i586-"
"mingw32msvc/bin/strip' pkgconfig = '/usr/bin/i586-mingw32msvc-pkg-config' "
"exe_wrapper = 'wine' # A command used to run generated executables.  ```"
msgstr ""
"```ini\n"
"[binaries]\n"
"c = '/usr/bin/i586-mingw32msvc-gcc'\n"
"cpp = '/usr/bin/i586-mingw32msvc-g++'\n"
"ar = '/usr/i586-mingw32msvc/bin/ar'\n"
"strip = '/usr/i586-mingw32msvc/bin/strip'\n"
"pkgconfig = '/usr/bin/i586-mingw32msvc-pkg-config'\n"
"exe_wrapper = 'wine' # A command used to run generated executables. \n"
"```"

#. type: Plain text
#: Cross-compilation.md:84
msgid ""
"The entries are pretty self explanatory but the last line is special. It "
"defines a *wrapper command* that can be used to run executables for this "
"host. In this case we can use Wine, which runs Windows applications on "
"Linux. Other choices include running the application with qemu or a hardware "
"simulator. If you have this kind of a wrapper, these lines are all you need "
"to write. Meson will automatically use the given wrapper when it needs to "
"run host binaries. This happens e.g. when running the project's test suite."
msgstr ""

#. type: Plain text
#: Cross-compilation.md:87
msgid ""
"The next section lists properties of the cross compiler and thus of the "
"target system. It looks like this:"
msgstr ""

#. type: Plain text
#: Cross-compilation.md:93
msgid "```ini [properties] sizeof_int = 4 sizeof_wchar_t = 4 sizeof_void* = 4"
msgstr ""
"```ini\n"
"[properties]\n"
"sizeof_int = 4\n"
"sizeof_wchar_t = 4\n"
"sizeof_void* = 4"

#. type: Plain text
#: Cross-compilation.md:97
msgid "alignment_char = 1 alignment_void* = 4 alignment_double = 4"
msgstr ""
"alignment_char = 1\n"
"alignment_void* = 4\n"
"alignment_double = 4"

#. type: Plain text
#: Cross-compilation.md:99
msgid "has_function_printf = true"
msgstr ""

#. type: Plain text
#: Cross-compilation.md:103
msgid ""
"c_args = ['-DCROSS=1', '-DSOMETHING=3'] c_link_args = ['-some_link_arg'] ```"
msgstr ""
"c_args = ['-DCROSS=1', '-DSOMETHING=3']\n"
"c_link_args = ['-some_link_arg']\n"
"```"

#. type: Plain text
#: Cross-compilation.md:112
msgid ""
"In most cases you don't need the size and alignment settings, Meson will "
"detect all these by compiling and running some sample programs. If your "
"build requires some piece of data that is not listed here, Meson will stop "
"and write an error message describing how to fix the issue. If you need "
"extra compiler arguments to be used during cross compilation you can set "
"them with `[langname]_args = [args]`. Just remember to specify the args as "
"an array and not as a single string (i.e. not as `'-DCROSS=1 -"
"DSOMETHING=3'`)."
msgstr ""

#. type: Plain text
#: Cross-compilation.md:126
msgid ""
"One important thing to note, if you did not define an `exe_wrapper` in the "
"previous section, is that Meson will make a best-effort guess at whether it "
"can run the generated binaries on the build machine. It determines whether "
"this is possible by looking at the `system` and `cpu_family` of build vs "
"host. There will however be cases where they do match up, but the build "
"machine is actually not compatible with the host machine. Typically this "
"will happen if the libc used by the build and host machines are "
"incompatible, or the code relies on kernel features not available on the "
"build machine. One concrete example is a macOS build machine producing "
"binaries for an iOS Simulator x86-64 host. They're both `darwin` and the "
"same architecture, but their binaries are not actually compatible. In such "
"cases you may use the `needs_exe_wrapper` property to override the auto-"
"detection:"
msgstr ""

#. type: Plain text
#: Cross-compilation.md:131
msgid "```ini [properties] needs_exe_wrapper = true ```"
msgstr ""
"```ini\n"
"[properties]\n"
"needs_exe_wrapper = true\n"
"```"

#. type: Plain text
#: Cross-compilation.md:138
msgid ""
"The last bit is the definition of host and target machines. Every cross "
"build definition must have one or both of them. If it had neither, the build "
"would not be a cross build but a native build. You do not need to define the "
"build machine, as all necessary information about it is extracted "
"automatically. The definitions for host and target machines look the same. "
"Here is a sample for host machine."
msgstr ""

#. type: Plain text
#: Cross-compilation.md:146
msgid ""
"```ini [host_machine] system = 'windows' cpu_family = 'x86' cpu = 'i686' "
"endian = 'little' ```"
msgstr ""
"```ini\n"
"[host_machine]\n"
"system = 'windows'\n"
"cpu_family = 'x86'\n"
"cpu = 'i686'\n"
"endian = 'little'\n"
"```"

#. type: Plain text
#: Cross-compilation.md:154
msgid ""
"These values define the machines sufficiently for cross compilation "
"purposes. The corresponding target definition would look the same but have "
"`target_machine` in the header. These values are available in your Meson "
"scripts. There are three predefined variables called, surprisingly, "
"`build_machine`, `host_machine` and `target_machine`. Determining the "
"operating system of your host machine is simply a matter of calling "
"`host_machine.system()`."
msgstr ""

#. type: Plain text
#: Cross-compilation.md:163
msgid ""
"There are two different values for the CPU. The first one is `cpu_family`. "
"It is a general type of the CPU. Common values might include `x86`, `arm` or "
"`x86_64`. The second value is `cpu` which is a more specific subtype for the "
"CPU. Typical values for a `x86` CPU family might include `i386` or `i586` "
"and for `arm` family `armv5` or `armv7hl`. Note that CPU type strings are "
"very system dependent. You might get a different value if you check its "
"value on the same machine but with different operating systems."
msgstr ""

#. type: Plain text
#: Cross-compilation.md:167
msgid ""
"If you do not define your host machine, it is assumed to be the build "
"machine. Similarly if you do not specify target machine, it is assumed to be "
"the host machine."
msgstr ""

#. type: Plain text
#: Cross-compilation.md:169
msgid "## Starting a cross build"
msgstr "## クロスビルドの開始"

#. type: Plain text
#: Cross-compilation.md:172
msgid "Once you have the cross file, starting a build is simple"
msgstr ""

#. type: Plain text
#: Cross-compilation.md:176
msgid "```console $ meson srcdir builddir --cross-file cross_file.txt ```"
msgstr ""
"```console\n"
"$ meson srcdir builddir --cross-file cross_file.txt\n"
"```"

#. type: Plain text
#: Cross-compilation.md:179
msgid ""
"Once configuration is done, compilation is started by invoking Ninja in the "
"usual way."
msgstr ""

#. type: Plain text
#: Cross-compilation.md:181
msgid "## Introspection and system checks"
msgstr ""

#. type: Plain text
#: Cross-compilation.md:184
msgid ""
"The main *meson* object provides two functions to determine cross "
"compilation status."
msgstr ""

#. type: Plain text
#: Cross-compilation.md:189
msgid ""
"```meson meson.is_cross_build()  # returns true when cross compiling meson."
"has_exe_wrapper() # returns true if an exe wrapper has been defined ```"
msgstr ""
"```meson\n"
"meson.is_cross_build()  # returns true when cross compiling\n"
"meson.has_exe_wrapper() # returns true if an exe wrapper has been defined\n"
"```"

#. type: Plain text
#: Cross-compilation.md:192
msgid ""
"Note that the latter gives undefined return value when doing a native build."
msgstr ""

#. type: Plain text
#: Cross-compilation.md:195
msgid ""
"You can run system checks on both the system compiler or the cross compiler. "
"You just have to specify which one to use."
msgstr ""

#. type: Plain text
#: Cross-compilation.md:199
msgid ""
"```meson build_compiler = meson.get_compiler('c', native : true)  "
"host_compiler = meson.get_compiler('c', native : false)"
msgstr ""
"```meson\n"
"build_compiler = meson.get_compiler('c', native : true) \n"
"host_compiler = meson.get_compiler('c', native : false)"

#. type: Plain text
#: Cross-compilation.md:203
msgid ""
"build_int_size = build_compiler.sizeof('int')  host_int_size = host_compiler."
"sizeof('int')  ```"
msgstr ""
"build_int_size = build_compiler.sizeof('int') \n"
"host_int_size = host_compiler.sizeof('int') \n"
"```"

#. type: Plain text
#: Cross-compilation.md:205
msgid "## Mixing host and build targets"
msgstr ""

#. type: Plain text
#: Cross-compilation.md:210
msgid ""
"Sometimes you need to build a tool which is used to generate source files. "
"These are then compiled for the actual target. For this you would want to "
"build some targets with the system's native compiler. This requires only one "
"extra keyword argument."
msgstr ""

#. type: Plain text
#: Cross-compilation.md:214
msgid ""
"```meson native_exe = executable('mygen', 'mygen.c', native : true)  ```"
msgstr ""
"```meson\n"
"native_exe = executable('mygen', 'mygen.c', native : true) \n"
"```"

#. type: Plain text
#: Cross-compilation.md:216
msgid ""
"You can then take `native_exe` and use it as part of a generator rule or "
"anything else you might want."
msgstr ""

#. type: Plain text
#: Cross-compilation.md:218
msgid "## Using a custom standard library"
msgstr ""

#. type: Plain text
#: Cross-compilation.md:223
msgid ""
"Sometimes in cross compilation you need to build your own standard library "
"instead of using the one provided by the compiler. Meson has built-in "
"support for switching standard libraries transparently. The invocation to "
"use in your cross file is the following:"
msgstr ""

#. type: Plain text
#: Cross-compilation.md:228
msgid ""
"```ini [properties] c_stdlib = ['mylibc', 'mylibc_dep'] # Subproject name, "
"dependency name ```"
msgstr ""
"```ini\n"
"[properties]\n"
"c_stdlib = ['mylibc', 'mylibc_dep'] # Subproject name, dependency name\n"
"```"

#. type: Plain text
#: Cross-compilation.md:234
msgid ""
"This specifies that C standard library is provided in the Meson subproject "
"`mylibc` in internal dependency variable `mylibc_dep`. It is used on every "
"cross built C target in the entire source tree (including subprojects) and "
"the standard library is disabled. The build definitions of these targets do "
"not need any modification."
msgstr ""

#. type: Plain text
#: Cross-compilation.md:236
msgid "## Changing cross file settings"
msgstr ""

#. type: Plain text
#: Cross-compilation.md:243
msgid ""
"Cross file settings are only read when the build directory is set up the "
"first time. Any changes to them after the fact will be ignored. This is the "
"same as regular compiles where you can't change the compiler once a build "
"tree has been set up. If you need to edit your cross file, then you need to "
"wipe your build tree and recreate it from scratch."
msgstr ""

#. type: Plain text
#: Cross-compilation.md:245
msgid "## Custom data"
msgstr "## カスタムデータ"

#. type: Plain text
#: Cross-compilation.md:248
msgid ""
"You can store arbitrary data in `properties` and access them from your Meson "
"files. As an example if you cross file has this:"
msgstr ""

#. type: Plain text
#: Cross-compilation.md:253
msgid "```ini [properties] somekey = 'somevalue' ```"
msgstr ""
"```ini\n"
"[properties]\n"
"somekey = 'somevalue'\n"
"```"

#. type: Plain text
#: Cross-compilation.md:255
msgid "then you can access that using the `meson` object like this:"
msgstr ""

#. type: Plain text
#: Cross-compilation.md:260
msgid ""
"```meson myvar = meson.get_cross_property('somekey')  # myvar now has the "
"value 'somevalue' ```"
msgstr ""
"```meson\n"
"myvar = meson.get_cross_property('somekey') \n"
"# myvar now has the value 'somevalue'\n"
"```"

#. type: Plain text
#: Cross-compilation.md:262
msgid "## Cross file locations"
msgstr ""

#. type: Plain text
#: Cross-compilation.md:269
msgid ""
"As of version 0.44.0 meson supports loading cross files from system "
"locations on Linux and the BSDs. This will be $XDG_DATA_DIRS/meson/cross, or "
"if XDG_DATA_DIRS is undefined, then /usr/local/share/meson/cross and /usr/"
"share/meson/cross will be tried in that order, for system wide cross files. "
"User local files can be put in $XDG_DATA_HOME/meson/cross, or ~/.local/share/"
"meson/cross if that is undefined."
msgstr ""

#. type: Plain text
#: Cross-compilation.md:274
#, no-wrap
msgid ""
"The order of locations tried is as follows:\n"
" - A file relative to the local dir\n"
" - The user local location\n"
" - The system wide locations in order\n"
msgstr ""

#. type: Plain text
#: Cross-compilation.md:278
msgid ""
"Linux and BSD distributions are encouraged to ship cross files either with "
"their cross compiler toolchain packages or as a standalone package, and put "
"them in one of the system paths referenced above."
msgstr ""

#. type: Plain text
#: Cross-compilation.md:282
msgid ""
"These files can be loaded automatically without adding a path to the cross "
"file. For example, if a ~/.local/share/meson/cross contains a file called "
"x86-linux, then the following command would start a cross build using that "
"cross files:"
msgstr ""

#. type: Plain text
#: Cross-compilation.md:285
msgid "```sh meson builddir/ --cross-file x86-linux ```"
msgstr "```sh meson builddir/ --cross-file x86-linux ```"
