# Japanese translations for PACKAGE package
# Copyright (C) 2017 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# Automatically generated, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2017-12-03 14:26+0900\n"
"PO-Revision-Date: 2017-09-30 21:43+0900\n"
"Last-Translator: Automatically generated\n"
"Language-Team: matsuand個人翻訳\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Plain text
#: Dependencies.md:1
#, no-wrap
msgid "---\n"
msgstr ""

#. type: Plain text
#: Dependencies.md:4
msgid ""
"short-description: Dependencies for external libraries and frameworks ..."
msgstr ""
"short-description: Dependencies for external libraries and frameworks\n"
"..."

#. type: Plain text
#: Dependencies.md:6
msgid "# Dependencies"
msgstr "# 依存関係"

#. type: Plain text
#: Dependencies.md:11
msgid ""
"Very few applications are fully self-contained, but rather they use external "
"libraries and frameworks to do their work. Meson makes it very easy to find "
"and use external dependencies. Here is how one would use the zlib "
"compression library."
msgstr ""

#. type: Plain text
#: Dependencies.md:16
msgid ""
"```meson zdep = dependency('zlib', version : '>=1.2.8')  exe = "
"executable('zlibprog', 'prog.c', dependencies : zdep)  ```"
msgstr ""
"```meson\n"
"zdep = dependency('zlib', version : '>=1.2.8') \n"
"exe = executable('zlibprog', 'prog.c', dependencies : zdep) \n"
"```"

#. type: Plain text
#: Dependencies.md:23
msgid ""
"First Meson is told to find the external library `zlib` and error out if it "
"is not found. The `version` keyword is optional and specifies a version "
"requirement for the dependency. Then an executable is built using the "
"specified dependency. Note how the user does not need to manually handle "
"compiler or linker flags or deal with any other minutiae."
msgstr ""

#. type: Plain text
#: Dependencies.md:25
msgid "If you have multiple dependencies, pass them as an array:"
msgstr ""

#. type: Plain text
#: Dependencies.md:29
msgid ""
"```meson executable('manydeps', 'file.c', dependencies : [dep1, dep2, dep3, "
"dep4])  ```"
msgstr ""
"```meson\n"
"executable('manydeps', 'file.c', dependencies : [dep1, dep2, dep3, dep4]) \n"
"```"

#. type: Plain text
#: Dependencies.md:32
msgid ""
"If the dependency is optional, you can tell Meson not to error out if the "
"dependency is not found and then do further configuration."
msgstr ""

#. type: Plain text
#: Dependencies.md:41
#, no-wrap
msgid ""
"```meson\n"
"opt_dep = dependency('somedep', required : false)\n"
"if opt_dep.found()\n"
"  # Do something.\n"
"else\n"
"  # Do something else.\n"
"endif\n"
"```\n"
msgstr ""

#. type: Plain text
#: Dependencies.md:45
msgid ""
"You can pass the `opt_dep` variable to target construction functions whether "
"the actual dependency was found or not. Meson will ignore non-found "
"dependencies."
msgstr ""

#. type: Plain text
#: Dependencies.md:50
msgid ""
"The dependency detector works with all libraries that provide a `pkg-config` "
"file. Unfortunately several packages don't provide pkg-config files. Meson "
"has autodetection support for some of these, and they are described later on "
"this page."
msgstr ""

#. type: Plain text
#: Dependencies.md:52
msgid "# Declaring your own"
msgstr ""

#. type: Plain text
#: Dependencies.md:56
msgid ""
"You can declare your own dependency objects that can be used interchangeably "
"with dependency objects obtained from the system. The syntax is "
"straightforward:"
msgstr ""

#. type: Plain text
#: Dependencies.md:63
#, no-wrap
msgid ""
"```meson\n"
"my_inc = include_directories(...)\n"
"my_lib = static_library(...)\n"
"my_dep = declare_dependency(link_with : my_lib,\n"
"  include_directories : my_inc)\n"
"```\n"
msgstr ""

#. type: Plain text
#: Dependencies.md:66
msgid ""
"This declares a dependency that adds the given include directories and "
"static library to any target you use it in."
msgstr ""

#. type: Plain text
#: Dependencies.md:68
msgid "# Building dependencies as subprojects"
msgstr ""

#. type: Plain text
#: Dependencies.md:73
msgid ""
"Many platforms do not provide a system package manager. On these systems "
"dependencies must be compiled from source. Meson's subprojects make it "
"simple to use system dependencies when they are available and to build "
"dependencies manually when they are not."
msgstr ""

#. type: Plain text
#: Dependencies.md:76
msgid ""
"To make this work, the dependency must have Meson build definitions and it "
"must declare its own dependency like this:"
msgstr ""

#. type: Plain text
#: Dependencies.md:78
#, no-wrap
msgid "    foo_dep = declare_dependency(...)\n"
msgstr ""

#. type: Plain text
#: Dependencies.md:81
msgid ""
"Then any project that wants to use it can write out the following "
"declaration in their main `meson.build` file."
msgstr ""

#. type: Plain text
#: Dependencies.md:83
#, no-wrap
msgid "    foo_dep = dependency('foo', fallback : ['foo', 'foo_dep'])\n"
msgstr ""

#. type: Plain text
#: Dependencies.md:92
msgid ""
"What this declaration means is that first Meson tries to look up the "
"dependency from the system (such as by using pkg-config). If it is not "
"available, then it builds subproject named `foo` and from that extracts a "
"variable `foo_dep`. That means that the return value of this function is "
"either an external or an internal dependency object. Since they can be used "
"interchangeably, the rest of the build definitions do not need to care which "
"one it is. Meson will take care of all the work behind the scenes to make "
"this work."
msgstr ""

#. type: Plain text
#: Dependencies.md:94
msgid "# Dependencies with custom lookup functionality"
msgstr ""

#. type: Plain text
#: Dependencies.md:96
msgid "## Boost"
msgstr ""

#. type: Plain text
#: Dependencies.md:100
msgid ""
"Boost is not a single dependency but rather a group of different libraries. "
"To use Boost headers-only libraries, simply add Boost as a dependency."
msgstr ""

#. type: Plain text
#: Dependencies.md:105
msgid ""
"```meson boost_dep = dependency('boost')  exe = executable('myprog', 'file."
"cc', dependencies : boost_dep)  ```"
msgstr ""
"```meson\n"
"boost_dep = dependency('boost') \n"
"exe = executable('myprog', 'file.cc', dependencies : boost_dep) \n"
"```"

#. type: Plain text
#: Dependencies.md:108
msgid ""
"To link against boost with Meson, simply list which libraries you would like "
"to use."
msgstr ""

#. type: Plain text
#: Dependencies.md:113
msgid ""
"```meson boost_dep = dependency('boost', modules : ['thread', 'utility'])  "
"exe = executable('myprog', 'file.cc', dependencies : boost_dep)  ```"
msgstr ""
"```meson\n"
"boost_dep = dependency('boost', modules : ['thread', 'utility']) \n"
"exe = executable('myprog', 'file.cc', dependencies : boost_dep) \n"
"```"

#. type: Plain text
#: Dependencies.md:116
msgid ""
"You can call `dependency` multiple times with different modules and use "
"those to link against your targets."
msgstr ""

#. type: Plain text
#: Dependencies.md:120
msgid ""
"If your boost headers or libraries are in non-standard locations you can set "
"the BOOST_ROOT, BOOST_INCLUDEDIR, and/or BOOST_LIBRARYDIR environment "
"variables."
msgstr ""

#. type: Plain text
#: Dependencies.md:123
msgid ""
"You can set the argument `threading` to `single` to use boost libraries that "
"has been compiled for single-threaded use instead."
msgstr ""

#. type: Plain text
#: Dependencies.md:125
msgid "## GTest and GMock"
msgstr ""

#. type: Plain text
#: Dependencies.md:131
msgid ""
"GTest and GMock come as sources that must be compiled as part of your "
"project. With Meson you don't have to care about the details, just pass "
"`gtest` or `gmock` to `dependency` and it will do everything for you. If you "
"want to use GMock, it is recommended to use GTest as well, as getting it to "
"work standalone is tricky."
msgstr ""

#. type: Plain text
#: Dependencies.md:133
msgid "## MPI"
msgstr ""

#. type: Plain text
#: Dependencies.md:140
#, no-wrap
msgid ""
"MPI is supported for C, C++ and Fortran. Because dependencies are\n"
"language-specific, you must specify the requested language using the\n"
"`language` keyword argument, i.e.,\n"
" * `dependency('mpi', language='c')` for the C MPI headers and libraries\n"
" * `dependency('mpi', language='cpp')` for the C++ MPI headers and libraries\n"
" * `dependency('mpi', language='fortran')` for the Fortran MPI headers and libraries\n"
msgstr ""

#. type: Plain text
#: Dependencies.md:147
msgid ""
"Meson prefers pkg-config for MPI, but if your MPI implementation does not "
"provide them, it will search for the standard wrapper executables, `mpic`, "
"`mpicxx`, `mpic++`, `mpifort`, `mpif90`, `mpif77`. If these are not in your "
"path, they can be specified by setting the standard environment variables "
"`MPICC`, `MPICXX`, `MPIFC`, `MPIF90`, or `MPIF77`, during configuration."
msgstr ""

#. type: Plain text
#: Dependencies.md:149
msgid "## Qt5"
msgstr ""

#. type: Plain text
#: Dependencies.md:152
msgid ""
"Meson has native Qt5 support. Its usage is best demonstrated with an example."
msgstr ""

#. type: Plain text
#: Dependencies.md:156
msgid ""
"```meson qt5_mod = import('qt5')  qt5widgets = dependency('qt5', modules : "
"'Widgets')"
msgstr ""
"```meson\n"
"qt5_mod = import('qt5')  qt5widgets = dependency('qt5', modules : 'Widgets')"

#. type: Plain text
#: Dependencies.md:163
#, no-wrap
msgid ""
"processed = qt5_mod.preprocess(\n"
"  moc_headers : 'mainWindow.h',   # Only headers that need moc should be put here\n"
"  moc_sources : 'helperFile.cpp', # must have #include\"moc_helperFile.cpp\"\n"
"  ui_files    : 'mainWindow.ui',\n"
"  qresources  : 'resources.qrc',\n"
")\n"
msgstr ""

#. type: Plain text
#: Dependencies.md:170
#, no-wrap
msgid ""
"q5exe = executable('qt5test',\n"
"  sources     : ['main.cpp',\n"
"                 'mainWindow.cpp',\n"
"                 processed],\n"
"  dependencies: qt5widgets)\n"
"```\n"
msgstr ""

#. type: Plain text
#: Dependencies.md:180
msgid ""
"Here we have an UI file created with Qt Designer and one source and header "
"file each that require preprocessing with the `moc` tool. We also define a "
"resource file to be compiled with `rcc`. We just have to tell Meson which "
"files are which and it will take care of invoking all the necessary tools in "
"the correct order, which is done with the `preprocess` method of the `qt5` "
"module. Its output is simply put in the list of sources for the target. The "
"`modules` keyword of `dependency` works just like it does with Boost. It "
"tells which subparts of Qt the program uses."
msgstr ""

#. type: Plain text
#: Dependencies.md:182
msgid "## Dependencies using config tools"
msgstr ""

#. type: Plain text
#: Dependencies.md:187
msgid ""
"CUPS, LLVM, PCAP, WxWidgets, libwmf, and GnuStep either do not provide pkg-"
"config modules or additionally can be detected via a config tool (cups-"
"config, llvm-config, etc). Meson has native support for these tools, and "
"then can be found like other dependencies:"
msgstr ""

#. type: Plain text
#: Dependencies.md:193
msgid ""
"```meson pcap_dep = dependency('pcap', version : '>=1.0')  cups_dep = "
"dependency('cups', version : '>=1.4')  llvm_dep = dependency('llvm', "
"version : '>=4.0')  ```"
msgstr ""
"```meson\npcap_dep = dependency('pcap', version : '>=1.0')\n"
"cups_dep = dependency('cups', version : '>=1.4')\n"
"llvm_dep = dependency('llvm', version : '>=4.0')\n"
"```"

#. type: Plain text
#: Dependencies.md:196
msgid ""
"Some of these tools (like wmf and cups) provide both pkg-config and config "
"tools support. You can force one or another via the method keyword:"
msgstr ""

#. type: Plain text
#: Dependencies.md:200
msgid "```meson wmf_dep = dependency('wmf', method : 'config-tool')  ```"
msgstr ""
"```meson\nwmf_dep = dependency('wmf', method : 'config-tool')\n```"

#. type: Plain text
#: Dependencies.md:202
msgid "## LLVM"
msgstr ""

#. type: Plain text
#: Dependencies.md:206
msgid ""
"Meson has native support for LLVM going back to version LLVM version 3.5.  "
"It supports a few additional features compared to other config-tool based "
"dependencies."
msgstr ""

#. type: Plain text
#: Dependencies.md:210
msgid ""
"As of 0.44.0 Meson supports the `static` keyword argument for LLVM. Before "
"this LLVM >= 3.9 would always dynamically link, while older versions would "
"statically link, due to a quirk in `llvm-config`."
msgstr ""

#. type: Plain text
#: Dependencies.md:212
msgid "### Modules, a.k.a. Components"
msgstr ""

#. type: Plain text
#: Dependencies.md:216
msgid ""
"Meson wraps LLVM's concept of components in it's own modules concept.  When "
"you need specific components you add them as modules as meson will do the "
"right thing:"
msgstr ""

#. type: Plain text
#: Dependencies.md:220
msgid ""
"```meson llvm_dep = dependency('llvm', version : '>= 4.0', modules : "
"['amdgpu'])  ```"
msgstr ""
"```meson\nllvm_dep = dependency('llvm', version : '>= 4.0', modules : "
"['amdgpu'])\n```"

#. type: Plain text
#: Dependencies.md:223
msgid ""
"As of 0.44.0 it can also take optional modules (these will affect the "
"arguments generated for a static link):"
msgstr ""

#. type: Plain text
#: Dependencies.md:228
#, no-wrap
msgid ""
"```meson\n"
"llvm_dep = dependency(\n"
"  'llvm', version : '>= 4.0', modules : ['amdgpu'], optional_modules : ['inteljitevents'],\n"
")\n"
"```\n"
msgstr ""
