fragment_downloaded_cb({"url": "Contributing.html#no-lingering-state", "fragment": "No lingering state \nMeson operates in much the same way as functional programming languages. It has inputs which include meson.build files values of options compilers and so on. These are passed to a function which generates output build definition. This function is pure which means that \nThe latter one is important because it enforces that there is no way for secret state to pass between consecutive invocations of Meson. This is the reason why for example there is no set_option function even though there is a get_option one. \nIf this were not the case we could never know if the build output is stable For example suppose there were a set_option function and a boolean variable flipflop. Then you could do this \nmeson set_option flipflop not get_option flipflop \nThis piece of code would never converge. Every Meson run would change the value of the option and thus the output you get out of this build definition would be random. \nMeson does not permit this by forbidding these sorts of covert channels. \nThere is one exception to this rule. Users can call into external commands with run_command. If the output of that command does not behave like a pure function this problem arises. Meson does not try to guard against this case it is the responsibility of the user to make sure the commands they run behave like pure functions. \n"});