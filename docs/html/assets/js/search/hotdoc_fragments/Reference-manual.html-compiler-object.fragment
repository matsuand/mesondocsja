fragment_downloaded_cb({"url": "Reference-manual.html#compiler-object", "fragment": "compiler object \nThis object is returned by meson.get_compiler lang It represents a compiler for a given language and allows you to query its properties. It has the following methods \nalignment typename returns the alignment of the type specified in the positional argument you can specify external dependencies to use with dependencies keyword argument. \ncompiles code returns true if the code fragment given in the positional argument compiles you can specify external dependencies to use with dependencies keyword argument code can be either a string containing source code or a file object pointing to the source code. \ncompute_int expr computes the value of the given expression as an example When cross compiling this is evaluated with an iterative algorithm you can specify keyword arguments low defaults to high defaults to and guess to specify max and min values for the search and the value to try first. \nfind_library lib_name tries to find the library specified in the positional argument. The result object can be used just like the return value of dependency. If the keyword argument required is false Meson will proceed even if the library is not found. By default the library is searched for in the system library directory e.g. usr lib This can be overridden with the dirs keyword argument which can be either a string or a list of strings. \nfirst_supported_argument list_of_strings given a list of strings returns the first argument that passes the has_argument test above or an empty array if none pass. \nget_define definename returns the given preprocessor symbol s value as a string or empty string if it is not defined. \nget_id returns a string identifying the compiler. For example gcc msvc and more. \nget_supported_arguments list_of_string added returns an array containing only the arguments supported by the compiler as if has_argument were called on them individually. \nhas_argument argument_name returns true if the compiler accepts the specified command line argument that is can compile code without erroring out or printing a warning about an unknown flag you can specify external dependencies to use with dependencies keyword argument. \nhas_function funcname returns true if the given function is provided by the standard library or a library passed in with the args keyword you can specify external dependencies to use with dependencies keyword argument. \nhas_header returns true if the specified header can be included you can specify external dependencies to use with dependencies keyword argument and extra code to put above the header test with the prefix keyword. In order to look for headers in a specific directory you can use args I extra include dir but this should only be used in exceptional cases for includes that can t be detected via pkg config and passed via dependencies. \nhas_header_symbol headername symbolname allows one to detect whether a particular symbol function variable define type definition etc is declared in the specified header you can specify external dependencies to use with dependencies keyword argument. \nhas_member typename membername takes two arguments type name and member name and returns true if the type has the specified member you can specify external dependencies to use with dependencies keyword argument. \nhas_members typename membername1 membername2 takes at least two arguments type name and one or more member names returns true if the type has all the specified members you can specify external dependencies to use with dependencies keyword argument. \nhas_multi_arguments arg1 arg2 arg3 is the same as has_argument but takes multiple arguments and uses them all in a single compiler invocation available since \nhas_type typename returns true if the specified token is a type you can specify external dependencies to use with dependencies keyword argument. \nlinks code returns true if the code fragment given in the positional argument compiles and links you can specify external dependencies to use with dependencies keyword argument code can be either a string containing source code or a file object pointing to the source code. \nrun code attempts to compile and execute the given code fragment returns a run result object you can specify external dependencies to use with dependencies keyword argument code can be either a string containing source code or a file object pointing to the source code. \nsymbols_have_underscore_prefix returns true if the C symbol mangling is one underscore _ prefixed to the symbol available since \nsizeof typename returns the size of the given type e.g. int or if the type is unknown to add includes set them in the prefix keyword argument you can specify external dependencies to use with dependencies keyword argument. \nversion returns the compiler s version number as a string. \nThe following keyword arguments can be used \nargs can be used to pass a list of compiler arguments that are required to find the header or symbol. For example you might need to pass the include path Isome path to header if a header is not in the default include path. In versions newer than you should use the include_directories keyword described above. You may also want to pass a library name lfoo for has_function to check for a function. Supported by all methods except get_id version and find_library. \ninclude_directories specifies extra directories for header searches. added \nname the name to use for printing a message about the compiler check. Supported by the methods compiles links and run If this keyword argument is not passed to those methods no message will be printed about the check. \nprefix can be used to add includes and other things that are required for the symbol to be declared. System definitions should be passed via compiler args eg _GNU_SOURCE is often required for some symbols to be exposed on Linux and it should be passed via args keyword argument see below Supported by the methods sizeof has_type has_function has_member has_members has_header_symbol. \nNote that if you have a single prefix with all your dependencies you might find it easier to append to the environment variables C_INCLUDE_PATH with GCC Clang and INCLUDE with MSVC to expand the default include path and LIBRARY_PATH with GCC Clang and LIB with MSVC to expand the default library search path. \nHowever with GCC these variables will be ignored when cross compiling. In that case you need to use a specs file. See http www.mingw.org wiki SpecsFileHOWTO \n"});