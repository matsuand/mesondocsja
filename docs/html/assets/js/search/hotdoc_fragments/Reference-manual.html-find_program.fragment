fragment_downloaded_cb({"url": "Reference-manual.html#find_program", "fragment": "find_program \nprogram_name1 here is a string that can be an executable or script to be searched for in PATH or a script in the current source directory. \nprogram_name2 and later positional arguments are used as fallback strings to search for. This is meant to be used for cases where the program may have many alternative names such as foo and foo.py. The function will check for the arguments one by one and the first one that is found is returned. Meson versions earlier than only accept one argument. \nKeyword arguments are the following \nrequired By default required is set to true and Meson will abort if no program can be found. If required is set to false Meson continue even if none of the programs can be found. You can then use the found method on the returned object to check whether it was found or not. \nnative since defines how this executable should be searched. By default it is set to false which causes Meson to first look for the executable in the cross file when cross building and if it is not defined there then from the system. If set to true the cross file is ignored and the program is only searched from the system. \nMeson will also autodetect scripts with a shebang line and run them with the executable interpreter specified in it both on Windows because the command invocator will reject the command otherwise and Unixes if the script file does not have the executable bit set Hence you must not manually add the interpreter while using this script as part of a list of commands. \nIf you need to check for a program in a non standard location you can just pass an absolute path to find_program e.g. setcap find_program setcap usr sbin setcap sbin setcap required false \nThis command takes the strings given to it in arguments and returns corresponding File objects that you can use as sources for build targets. The difference is that file objects remember the subdirectory they were defined in and can be used anywhere in the source tree. As an example suppose you have source file foo.cpp in subdirectory bar1 and you would like to use it in a build target that is defined in bar2. To make this happen you first create the object in bar1 like this \nThen you can use it in bar2 like this \nMeson will then do the right thing. \n"});