fragment_downloaded_cb({"url": "Cross-compilation.html#page-description", "fragment": "Introspection and system checks \nUsing a custom standard library \nMeson has full support for cross compilation. Since cross compiling is more complicated than native building let s first go over some nomenclature. The three most important definitions are traditionally called build host and target. This is confusing because those terms are used for quite many different things. To simplify the issue we are going to call these the build machine host machine and target machine. Their definitions are the following \nThe tl dr summary is the following if you are doing regular cross compilation you only care about build_machine and host_machine. Just ignore target_machine altogether and you will be correct of the time. If your needs are more complex or you are interested in the actual details do read on. \nThis might be easier to understand through examples. Let s start with the regular not cross compiling case. In these cases all of these three machines are the same. Simple so far. \nLet s next look at the most common cross compilation setup. Let s suppose you are on a bit OSX machine and you are cross compiling a binary that will run on a bit ARM Linux board. In this case your build machine is bit OSX and both your host and target machines are bit ARM Linux. This should be quite understandable as well. \nIt gets a bit trickier when we think about how the cross compiler was generated. It was built and it runs on a specific platform but the output it generates is for a different platform. In this case build and host machines are the same but target machine is different. \nThe most complicated case is when you cross compile a cross compiler. As an example you can on a Linux machine generate a cross compiler that runs on Windows but produces binaries on MIPS Linux. In this case build machine is x86 Linux host machine is x86 Windows and target machine is MIPS Linux. This setup is known as the Canadian Cross. As a side note be careful when reading cross compilation articles on Wikipedia or the net in general. It is very common for them to get build host and target mixed up even in consecutive sentences which can leave you puzzled until you figure it out. \nIf you did not understand all of the details don t worry. For most people it takes a while to wrap their head around these concepts. Don t panic it might take a while to click but you will get the hang of it eventually. \nThe main meson object provides two functions to determine cross compilation status. \nNote that the latter gives undefined return value when doing a native build. \nYou can run system checks on both the system compiler or the cross compiler. You just have to specify which one to use. \nSometimes in cross compilation you need to build your own standard library instead of using the one provided by the compiler. Meson has built in support for switching standard libraries transparently. The invocation to use in your cross file is the following \nThis specifies that C standard library is provided in the Meson subproject mylibc in internal dependency variable mylibc_dep. It is used on every cross built C target in the entire source tree including subprojects and the standard library is disabled. The build definitions of these targets do not need any modification. \n"});