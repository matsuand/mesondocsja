fragment_downloaded_cb({"fragment": "Building dependencies as subprojects \nDependencies with custom lookup functionality \nDependencies using config tools \nVery few applications are fully self contained but rather they use external libraries and frameworks to do their work. Meson makes it very easy to find and use external dependencies. Here is how one would use the zlib compression library. \nFirst Meson is told to find the external library zlib and error out if it is not found. The version keyword is optional and specifies a version requirement for the dependency. Then an executable is built using the specified dependency. Note how the user does not need to manually handle compiler or linker flags or deal with any other minutiae. \nIf you have multiple dependencies pass them as an array \nIf the dependency is optional you can tell Meson not to error out if the dependency is not found and then do further configuration. \nYou can pass the opt_dep variable to target construction functions whether the actual dependency was found or not. Meson will ignore non found dependencies. \nThe dependency detector works with all libraries that provide a pkg config file. Unfortunately several packages don t provide pkg config files. Meson has autodetection support for some of these and they are described later on this page. \nMany platforms do not provide a system package manager. On these systems dependencies must be compiled from source. Meson s subprojects make it simple to use system dependencies when they are available and to build dependencies manually when they are not. \nTo make this work the dependency must have Meson build definitions and it must declare its own dependency like this \nThen any project that wants to use it can write out the following declaration in their main meson.build file. \nWhat this declaration means is that first Meson tries to look up the dependency from the system such as by using pkg config If it is not available then it builds subproject named foo and from that extracts a variable foo_dep. That means that the return value of this function is either an external or an internal dependency object. Since they can be used interchangeably the rest of the build definitions do not need to care which one it is. Meson will take care of all the work behind the scenes to make this work. \nCUPS LLVM PCAP WxWidgets libwmf and GnuStep either do not provide pkg config modules or additionally can be detected via a config tool cups config llvm config etc Meson has native support for these tools and then can be found like other dependencies \n", "url": "Dependencies.html#page-description"});